/**
 * Peer assignment management for video assessment
 *
 * @module     mod_videoassessment/peer_assignment
 * @copyright  2024 Don Hinkleman (hinkelman@mac.com)
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */
define(['jquery'], function($) {
    let students = {};
    let allUsers = {}; // Includes students + teachers for name lookups.
    let peerAssignments = {};
    let isExisting = false;
    let cmid = 0;
    let sesskey = '';
    let usedpeers = 0;
    let groups = {};

    /**
     * Update the hidden form field with current peer assignments.
     */
    function updateHiddenField() {
        const jsonValue = JSON.stringify(peerAssignments);
        // Try multiple selectors to find the hidden field.
        let field = $('#id_peerassignments');
        if (field.length === 0) {
            field = $('input[name="peerassignments"]');
        }
        if (field.length > 0) {
            field.val(jsonValue);
        } else {
            console.error('Hidden field not found! Trying to create one...');
            // Create the hidden field if it doesn't exist.
            $('form.mform').append('<input type="hidden" name="peerassignments" id="id_peerassignments" value="' + jsonValue.replace(/"/g, '&quot;') + '">');
            console.log('Created hidden field with value:', jsonValue);
        }
    }

    /**
     * Get the current maximum number of peers allowed per user.
     *
     * @return {number} The maximum number of peers (0 = unlimited)
     */
    function getMaxPeers() {
        const val = parseInt($('#id_usedpeers').val());
        return isNaN(val) ? usedpeers : val;
    }

    /**
     * Add a peer to a user.
     *
     * @param {number} userid - The user ID
     * @param {number} peerid - The peer ID to add
     */
    function addPeer(userid, peerid) {
        console.log('Adding peer:', peerid, 'to user:', userid);
        if (!peerAssignments[userid]) {
            peerAssignments[userid] = [];
        }

        // Check if we've reached the maximum number of peers.
        const maxPeers = getMaxPeers();
        if (maxPeers > 0 && peerAssignments[userid].length >= maxPeers) {
            console.log('Maximum peers reached for user:', userid, '(limit:', maxPeers, ')');
            return; // Don't add more peers.
        }

        if (peerAssignments[userid].indexOf(peerid) === -1) {
            peerAssignments[userid].push(peerid);
        }

        console.log('Current peerAssignments:', peerAssignments);
        renderPeersForUser(userid);
        updateHiddenField();
    }

    /**
     * Remove a peer from a user.
     *
     * @param {number} userid - The user ID
     * @param {number} peerid - The peer ID to remove
     */
    function removePeer(userid, peerid) {
        console.log('removePeer: userid:', userid, 'peerid:', peerid, 'peerAssignments:', peerAssignments);
        
        // Try multiple key formats to find the user's peer assignments.
        const userPeers = peerAssignments[userid] || peerAssignments[parseInt(userid)] || peerAssignments[String(userid)] || [];
        
        if (!Array.isArray(userPeers) || userPeers.length === 0) {
            console.log('No peers found for user:', userid);
            return;
        }
        
        // Find the peer to remove, handling type mismatches (string vs number).
        const peeridNum = parseInt(peerid);
        const peeridStr = String(peerid);
        
        // Try to find the index using both number and string comparison.
        let index = userPeers.indexOf(peerid);
        if (index === -1 && !isNaN(peeridNum)) {
            index = userPeers.indexOf(peeridNum);
        }
        if (index === -1) {
            index = userPeers.indexOf(peeridStr);
        }
        // Also try comparing each element as both number and string.
        if (index === -1) {
            index = userPeers.findIndex(function(p) {
                return p == peerid || parseInt(p) === peeridNum || String(p) === peeridStr;
            });
        }
        
        if (index > -1) {
            // Use the correct key format to update.
            const key = peerAssignments[userid] ? userid : (peerAssignments[parseInt(userid)] ? parseInt(userid) : String(userid));
            peerAssignments[key].splice(index, 1);
            console.log('Peer removed successfully. Updated peerAssignments:', peerAssignments);
        } else {
            console.warn('Peer not found in array. userPeers:', userPeers, 'peerid:', peerid, 'peeridNum:', peeridNum, 'peeridStr:', peeridStr);
        }

        renderPeersForUser(userid);
        updateHiddenField();
    }
    
    /**
     * Render badges for all users found in the table rows.
     * This ensures teachers and all users get re-rendered after any operation.
     */
    function renderAllUsersInTable() {
        console.log('renderAllUsersInTable: Rendering all users in table...');
        const tableRows = $('tr[data-userid]');
        console.log('Found', tableRows.length, 'table rows with data-userid');
        
        // Collect all unique user IDs from multiple sources.
        const allUserIds = new Set();
        
        // Add users from table rows.
        tableRows.each(function() {
            const userid = parseInt($(this).attr('data-userid'));
            if (!isNaN(userid) && userid > 0) {
                allUserIds.add(userid);
            }
        });
        
        // Add users from peerAssignments.
        Object.keys(peerAssignments).forEach(function(key) {
            const uid = parseInt(key);
            if (!isNaN(uid) && uid > 0) {
                allUserIds.add(uid);
            }
        });
        
        // Add users from allUsers.
        Object.keys(allUsers).forEach(function(key) {
            const uid = parseInt(key);
            if (!isNaN(uid) && uid > 0) {
                allUserIds.add(uid);
            }
        });
        
        console.log('Rendering badges for', allUserIds.size, 'unique users:', Array.from(allUserIds));
        
        // Render for all unique user IDs.
        allUserIds.forEach(function(userid) {
            renderPeersForUser(userid);
        });
    }

    /**
     * Render the peers display for a specific user.
     *
     * @param {number} userid - The user ID
     */
    function renderPeersForUser(userid) {
        // Normalize userid to number for consistent lookup.
        const userIdNum = parseInt(userid);
        if (isNaN(userIdNum) || userIdNum <= 0) {
            console.warn('Invalid user ID in renderPeersForUser:', userid);
            return;
        }
        
        // Try multiple container ID formats.
        let container = $('#assigned-peers-' + userIdNum);
        if (container.length === 0) {
            container = $('#assigned-peers-' + userid);
        }
        if (container.length === 0) {
            // Try finding container by row data attribute.
            const row = $('tr[data-userid="' + userIdNum + '"]');
            if (row.length > 0) {
                container = row.find('#assigned-peers-' + userIdNum);
                if (container.length === 0) {
                    container = row.find('.assigned-peers');
                }
            }
        }
        if (container.length === 0) {
            // Don't warn if this user isn't in the table (e.g., teachers filtered out).
            // Only warn if we're trying to render for a user that should be in the table.
            const rowExists = $('tr[data-userid="' + userIdNum + '"]').length > 0;
            if (rowExists) {
                console.warn('Container not found for user ID:', userIdNum, '(row exists but container missing)');
            }
            return;
        }
        
        container.empty();

        // Try multiple key formats to get user peers.
        let userPeers = peerAssignments[userIdNum] || peerAssignments[userid] || peerAssignments[String(userIdNum)] || peerAssignments[String(userid)] || [];
        
        // Ensure we have an array.
        if (!Array.isArray(userPeers)) {
            userPeers = [];
        }
        
        const maxPeers = getMaxPeers();
        const atLimit = maxPeers > 0 && userPeers.length >= maxPeers;

        userPeers.forEach(function(peerid) {
            // Convert peerid to number for consistent lookup.
            const peeridNum = parseInt(peerid);
            if (isNaN(peeridNum) || peeridNum <= 0) {
                console.warn('Invalid peer ID:', peerid, 'for user:', userIdNum);
                return; // Skip invalid peer IDs.
            }
            
            // Use allUsers for peer name lookup.
            let peername = allUsers[peeridNum] || allUsers[peerid] || allUsers[String(peeridNum)] || allUsers[String(peerid)];
            
            // Fallback to students if not found in allUsers.
            if (!peername) {
                peername = students[peeridNum] || students[peerid] || students[String(peeridNum)] || students[String(peerid)];
            }
            
            // If still no name found, use a fallback.
            if (!peername) {
                peername = 'User ' + peeridNum;
            }
            
                const badge = $('<span class="peer-badge badge bg-secondary text-dark me-1 mb-1"></span>')
                .attr('data-peerid', peeridNum)
                .css({'display': 'inline-block', 'margin': '2px'});

            badge.text(peername + ' ');

            const removeLink = $('<a href="#" class="remove-peer text-white">Ã—</a>')
                .attr('data-userid', userIdNum)
                .attr('data-peerid', peeridNum)
                .css({'text-decoration': 'none', 'font-weight': 'bold'});

            badge.append(removeLink);
            container.append(badge);
        });

        // Update the dropdown - disable if at limit or if peer already assigned.
        const select = $('select.add-peer-select[data-userid="' + userid + '"]');

        if (atLimit) {
            // Disable the entire dropdown when limit is reached.
            select.prop('disabled', true);
            select.css('opacity', '0.5');
        } else {
            // Always enable the dropdown if not at limit.
            select.prop('disabled', false);
            select.css('opacity', '1');
            select.removeAttr('disabled'); // Ensure it's not disabled.

            // Enable/disable individual options based on whether already assigned.
            select.find('option').each(function() {
                const optionValue = parseInt($(this).val());
                if (!optionValue || isNaN(optionValue)) {
                    // Placeholder option - always enabled.
                    $(this).prop('disabled', false);
                } else {
                    // Check if this peer is already assigned (compare both as numbers and strings).
                    const isAssigned = userPeers.some(function(p) { 
                        return parseInt(p) === optionValue || p === optionValue || String(p) === String(optionValue);
                    });
                    $(this).prop('disabled', isAssigned);
                }
            });
        }
        select.val('');
    }

    /**
     * Assign peers randomly across all students (course-wide).
     */
    function assignRandomPeersCourse() {
        // Get number of peers from the usedpeers input.
        let numPeers = parseInt($('#id_usedpeers').val()) || usedpeers;
        if (numPeers <= 0) {
            numPeers = 1; // Default to 1 if not set.
        }

        const studentIds = Object.keys(students).map(Number);

        if (studentIds.length <= numPeers) {
            alert('Not enough students to assign ' + numPeers + ' peers each.');
            return;
        }

        // Confirm before proceeding.
        if (!confirm('This will reset all peer assignments and assign ' + numPeers + ' random peer(s) to each student. Continue?')) {
            return;
        }

        // Clear existing assignments.
        peerAssignments = {};

        // Simple random assignment algorithm.
        studentIds.forEach(function(userid) {
            peerAssignments[userid] = [];
            const availablePeers = studentIds.filter(function(id) {
                return id !== userid;
            });

            // Shuffle available peers.
            for (let i = availablePeers.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [availablePeers[i], availablePeers[j]] = [availablePeers[j], availablePeers[i]];
            }

            // Assign the first numPeers.
            peerAssignments[userid] = availablePeers.slice(0, numPeers);
        });

        // Re-render all users (students only for course assignment).
        studentIds.forEach(function(userid) {
            renderPeersForUser(userid);
        });
        
        // Also render for ALL users in the table (from allUsers) to ensure teachers and everyone gets updated.
        // This ensures badges show up for all users, including teachers who might have manual assignments.
        Object.keys(allUsers).forEach(function(key) {
            const uid = parseInt(key);
            if (!isNaN(uid) && uid > 0) {
                renderPeersForUser(uid);
            }
        });
        
        // Render all users in the table (including teachers) to ensure everyone gets re-rendered.
        renderAllUsersInTable();

        updateHiddenField();
    }

    /**
     * Assign peers randomly within a specific group.
     *
     * @param {number} groupId - The group ID to assign peers within
     */
    function assignRandomPeersGroup(groupId) {
        // Get number of peers from the usedpeers input.
        let numPeers = parseInt($('#id_usedpeers').val()) || usedpeers;
        if (numPeers <= 0) {
            numPeers = 1; // Default to 1 if not set.
        }

        // Convert groupId to number and try both string and number keys.
        const groupIdNum = parseInt(groupId);
        let group = groups[groupIdNum] || groups[groupId] || groups[String(groupId)];
        
        if (!group) {
            alert('Group not found. Please try again.');
            return;
        }

        // Include all group members (students and teachers).
        const groupMembers = group.members || [];
        
        // Need at least (numPeers + 1) members in the group to assign numPeers peers to each.
        if (groupMembers.length <= numPeers) {
            const maxPossiblePeers = Math.max(0, groupMembers.length - 1);
            let errorMsg = 'Not enough members in group "' + group.name + '" to assign ' + numPeers + ' peer(s) to each member.';
            if (groupMembers.length > 0) {
                errorMsg += ' The group has ' + groupMembers.length + ' member(s), so each member can have at most ' + maxPossiblePeers + ' peer(s).';
            } else {
                errorMsg += ' The group has no members.';
            }
            alert(errorMsg);
            return;
        }

        // Confirm before proceeding.
        if (!confirm('This will reset peer assignments for all members in "' + group.name + '" and assign ' + numPeers + ' random peer(s) from within the group. Continue?')) {
            return;
        }

        // Clear existing assignments for group members.
        groupMembers.forEach(function(userid) {
            peerAssignments[userid] = [];
        });

        // Simple random assignment algorithm (same as course assignment).
        groupMembers.forEach(function(userid) {
            const availablePeers = groupMembers.filter(function(id) {
                return id !== userid;
            });

            // Shuffle available peers.
            for (let i = availablePeers.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [availablePeers[i], availablePeers[j]] = [availablePeers[j], availablePeers[i]];
            }

            // Assign the first numPeers.
            peerAssignments[userid] = availablePeers.slice(0, numPeers);
        });

        // Re-render group members.
        groupMembers.forEach(function(userid) {
            renderPeersForUser(userid);
        });
        
        renderAllUsersInTable();

        updateHiddenField();
    }

    /**
     * Initialize the peer assignment interface.
     *
     * @param {Object} params - Initialization parameters
     */
    function init(params) {
        // Wait for document to be ready.
        $(function() {
            try {
                console.log('Peer assignment init called with params:', params);
                students = params.students || {};
                allUsers = params.allUsers || params.students || {}; // Fallback to students if allUsers not provided.
                peerAssignments = params.existingPeers || {};
                isExisting = params.isExisting || false;
                cmid = params.cmid || 0;
                sesskey = params.sesskey || '';
                usedpeers = params.usedpeers || 0;
                groups = params.groups || {};
                
                // Normalize keys in students and allUsers to ensure consistent lookup (both numeric and string keys).
                const normalizeKeys = function(obj) {
                    if (!obj || typeof obj !== 'object') {
                        return {};
                    }
                    const normalized = {};
                    Object.keys(obj).forEach(function(key) {
                        const numKey = parseInt(key);
                        if (!isNaN(numKey)) {
                            normalized[numKey] = obj[key];
                            // Also keep string key for backward compatibility.
                            if (String(numKey) !== String(key)) {
                                normalized[key] = obj[key];
                            }
                        } else {
                            normalized[key] = obj[key];
                        }
                    });
                    return normalized;
                };
                
                students = normalizeKeys(students);
                allUsers = normalizeKeys(allUsers);
                
                // Ensure group IDs are numeric keys for consistency.
                const numericGroups = {};
                Object.keys(groups).forEach(function(key) {
                    numericGroups[parseInt(key)] = groups[key];
                });
                groups = numericGroups;

                console.log('Normalized students:', students);
                console.log('Normalized allUsers:', allUsers);
                console.log('Groups:', groups);
                console.log('Initial peerAssignments:', peerAssignments);

                // Convert peer arrays to have numeric keys and normalize peer IDs.
                const numericPeers = {};
                Object.keys(peerAssignments).forEach(function(key) {
                    const userId = parseInt(key);
                    if (!isNaN(userId) && userId > 0) {
                        // Normalize peer IDs to numbers.
                        const peers = (peerAssignments[key] || []).map(function(pid) {
                            const pnum = parseInt(pid);
                            return isNaN(pnum) ? pid : pnum;
                        }).filter(function(pid) {
                            return pid > 0;
                        });
                        numericPeers[userId] = peers;
                        // Also keep string key for backward compatibility.
                        if (String(userId) !== String(key)) {
                            numericPeers[key] = peers;
                        }
                    }
                });
                peerAssignments = numericPeers;

                console.log('After conversion peerAssignments:', peerAssignments);
                console.log('Students:', students);
                console.log('allUsers:', allUsers);

                // Collect all user IDs from both peerAssignments and allUsers.
                // This ensures we render badges for all users in the table.
                const allUserIds = new Set();
                
                // Add all users from peerAssignments.
                Object.keys(peerAssignments).forEach(function(key) {
                    const uid = parseInt(key);
                    if (!isNaN(uid) && uid > 0) {
                        allUserIds.add(uid);
                    }
                });
                
                // Add all users from allUsers (includes students + teachers from groups).
                Object.keys(allUsers).forEach(function(key) {
                    const uid = parseInt(key);
                    if (!isNaN(uid) && uid > 0) {
                        allUserIds.add(uid);
                    }
                });
                
                // Render peers for all users (both those with assignments and those without).
                // This ensures all badges are rendered and dropdowns are initialized.
                allUserIds.forEach(function(userid) {
                    renderPeersForUser(userid);
                });
                
                console.log('Rendered peers for', allUserIds.size, 'users');

                // Initialize the hidden field.
                updateHiddenField();

                // Handle add peer dropdown change (using event delegation).
                $(document).off('change.peerassign', '.add-peer-select');
                $(document).on('change.peerassign', '.add-peer-select', function() {
                    const userid = parseInt($(this).data('userid'));
                    const peerid = parseInt($(this).val());

                    if (peerid) {
                        addPeer(userid, peerid);
                    }
                });

                // Handle remove peer click (using event delegation).
                $(document).off('click.peerassign', '.remove-peer');
                $(document).on('click.peerassign', '.remove-peer', function(e) {
                    e.preventDefault();
                    const userid = parseInt($(this).data('userid'));
                    const peerid = parseInt($(this).data('peerid'));

                    removePeer(userid, peerid);
                });

                // Handle random assignment - Course button.
                const courseBtn = $('#random-peers-course');
                if (courseBtn.length) {
                    courseBtn.off('click.peerassign');
                    courseBtn.on('click.peerassign', function(e) {
                        e.preventDefault();
                        assignRandomPeersCourse();
                    });
                }

                // Initialize Bootstrap dropdown for the group button.
                const groupDropdownBtn = document.getElementById('random-peers-group-dropdown');
                if (groupDropdownBtn) {
                    // Initialize Bootstrap 5 dropdown if available.
                    if (typeof bootstrap !== 'undefined' && bootstrap.Dropdown) {
                        new bootstrap.Dropdown(groupDropdownBtn);
                    }
                }

                // Handle random assignment - Group dropdown items.
                $(document).off('click.peerassign', '.random-peers-group-item');
                $(document).on('click.peerassign', '.random-peers-group-item', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    const groupIdAttr = $(this).data('groupid');
                    const groupId = parseInt(groupIdAttr);
                    console.log('Group dropdown item clicked, groupIdAttr:', groupIdAttr, 'groupId:', groupId, 'groups:', groups);
                    if (groupId && !isNaN(groupId)) {
                        assignRandomPeersGroup(groupId);
                        // Close the dropdown manually.
                        const dropdown = $(this).closest('.dropdown');
                        const dropdownBtn = dropdown.find('.dropdown-toggle');
                        if (typeof bootstrap !== 'undefined' && bootstrap.Dropdown) {
                            const dropdownInstance = bootstrap.Dropdown.getInstance(dropdownBtn[0]);
                            if (dropdownInstance) {
                                dropdownInstance.hide();
                            }
                        } else {
                            // Fallback for Bootstrap 4 or if bootstrap is not available.
                            dropdown.removeClass('show');
                            dropdown.find('.dropdown-menu').removeClass('show');
                            dropdownBtn.attr('aria-expanded', 'false');
                        }
                    } else {
                        console.error('Invalid groupId:', groupId, 'from attr:', groupIdAttr);
                        alert('Invalid group selected. Please try again.');
                    }
                });

                // Listen for changes to Number of Peer Assessors to trim excess peers and update dropdowns.
                const usedPeersInput = $('#id_usedpeers');
                if (usedPeersInput.length) {
                    usedPeersInput.on('change keyup blur', function() {
                        const maxPeers = getMaxPeers();
                        
                        // If maxPeers > 0, trim excess peers from all users.
                        if (maxPeers > 0) {
                            Object.keys(peerAssignments).forEach(function(userid) {
                                const userPeers = peerAssignments[userid] || [];
                                if (userPeers.length > maxPeers) {
                                    // Remove excess peers from the end.
                                    peerAssignments[userid] = userPeers.slice(0, maxPeers);
                                }
                            });
                        }
                        
                        // Re-render all users to update UI.
                        Object.keys(students).forEach(function(userid) {
                            renderPeersForUser(parseInt(userid));
                        });
                        
                        // Update the hidden field with trimmed assignments.
                        updateHiddenField();
                    });
                }

                // Ensure hidden field is updated before form submission.
                const form = $('form.mform');
                if (form.length) {
                    form.off('submit.peerassign');
                    form.on('submit.peerassign', function() {
                        updateHiddenField();
                    });
                }

                // Also update on any form button click (Save, Cancel, etc.)
                const submitBtns = $('form.mform input[type="submit"]');
                if (submitBtns.length) {
                    submitBtns.off('click.peerassign');
                    submitBtns.on('click.peerassign', function() {
                        updateHiddenField();
                    });
                }

                console.log('Peer assignment initialization complete');
            } catch (error) {
                console.error('Error initializing peer assignment:', error);
            }
        });
    }

    return {
        init: init
    };
});

